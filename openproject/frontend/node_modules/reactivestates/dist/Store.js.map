{"version":3,"sources":["../src/Store.ts"],"names":["createInputState","name","is","InputState_1","input","logEnabled","_","require","Subject_1","StoreLog_1","Store","data","this","actionCompleted","Subject","currentData","states","forIn","value","key","inputState","undefined","putValue","prototype","action","fn","options","_this","outerData","isNil","transientDataInAction","innerData","clone","apply","newFields","Set","changedFields","newAndChangedFields","stack","Error","logEvent","LogEvent","keysIn","forEach","fieldName","hasIn","valueInOrigin","eq","add","changes","push","logStoreEvent","next","afterAction","Object","defineProperty","select","fields","_i","arguments","length","futureChanges","filter","touchedFields","some","f","has","every","field","state","hasValue","startWith","map","selectAll","keysWithValues","get","exports"],"mappings":"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","file":"Store.js","sourcesContent":["import * as _ from \"lodash\";\nimport {Observable} from \"rxjs/Observable\";\nimport {Subject} from \"rxjs/Subject\";\n// import \"zone.js\";\nimport {input, InputState} from \"./InputState\";\nimport {LogEvent, logStoreEvent} from \"./StoreLog\";\n\nexport type StateMembers<T> = { [P in keyof T]: InputState<T[P]>; };\n\nexport interface ActionOptions<T> {\n    // name?: string;\n    afterAction?: (store: Store<T>, data: T, touchedFields: Set<string>, newFields: Set<string>) => void;\n}\n\nexport interface SelectEvent<T> {\n    data: T;\n    fields: Set<keyof T>;\n}\n\nfunction createInputState(name: string) {\n    const is = input<any>();\n    is.name = name;\n    is.logEnabled = false;\n    return is;\n}\n\n// function getCallerInfo(stack: string|undefined) {\n//     if (stack === undefined) {\n//         return \"<unkown>\";\n//     }\n//\n//     const lines = stack.split(\"\\n\");\n//     let source = lines[2].trim();\n//     source = source.substr(3); // remove 'at '\n//     let end = source.indexOf(\" (\");\n//     if (end >= 0) {\n//         source = source.substring(0, end);\n//     }\n//\n//     return source;\n// }\n\n// const ZoneKeyData = \"ReactiveStatesStoreData\";\n// const ZoneKeyMethodName = \"ReactiveStatesStoreMethodName\";\n\nexport abstract class Store<T> {\n\n    readonly states: StateMembers<T>;\n\n    private currentData: T;\n\n    private transientDataInAction: T;\n\n    // private dataThreadLocal: T | null = null;\n\n    private actionCompleted = new Subject<Set<keyof T>>();\n\n    constructor(data: T) {\n        this.currentData = data;\n\n        const states: any = {};\n        _.forIn(this.currentData, (value: any, key: string) => {\n            let inputState = createInputState(key);\n            if (value !== undefined) {\n                inputState.putValue(value);\n            }\n            states[key] = inputState;\n        });\n        this.states = states;\n\n        // this.wrapMethodsInZones();\n    }\n\n    // private wrapMethodsInZones() {\n    //     const functions = _.functions(Object.getPrototypeOf(this));\n    //     const self: any = this;\n    //     functions.forEach(functionName => {\n    //         const original: any = _.get(this, functionName);\n    //         _.set(this, functionName, function () {\n    //             const props: any = {};\n    //             props[ZoneKeyMethodName] = functionName;\n    //             const fnZone = Zone.current.fork({name: functionName, properties: props});\n    //             fnZone.run(original, self, arguments as any);\n    //         });\n    //     });\n    // }\n\n    protected action(name: string, fn: (data: T, bla: any) => void, options?: ActionOptions<T>) {\n\n        options = options ? options : {};\n\n        const outerData: any = !_.isNil(this.transientDataInAction) ? this.transientDataInAction : this.data;\n        const innerData: any = _.clone(outerData);\n        this.transientDataInAction = innerData;\n        // const properties: any = {};\n        // properties[ZoneKeyData] = innerData;\n        // let childZone = Zone.current.fork({\n        //     name: \"action\",\n        //     properties\n        // });\n        // childZone.run(fn, this, [innerData]);\n        fn.apply(this, [innerData]);\n        // this.currentData = innerData;\n        this.transientDataInAction = outerData;\n\n        const newFields = new Set<string>();\n        const changedFields = new Set<string>();\n        const newAndChangedFields = new Set<string>();\n\n        // Get method and action name for logging\n        let stack = new Error().stack;\n        // const caller = getCallerInfo(stack);\n        // let txName = options.name;\n        // txName = txName !== undefined ? \" / \" + txName : \"\";\n\n        const logEvent = new LogEvent(name, [], stack);\n\n        // Check changes\n        // const dataInCurrentZone: any = this.data;\n        _.keysIn(innerData).forEach(fieldName => {\n            const value = innerData[fieldName];\n            if (_.hasIn(outerData, fieldName)) {\n                const valueInOrigin = outerData[fieldName];\n                if (!_.eq(value, valueInOrigin)) {\n                    // field changed\n                    this.states[fieldName].putValue(value);\n                    outerData[fieldName] = value;\n                    changedFields.add(fieldName);\n                    newAndChangedFields.add(fieldName);\n\n                    if (_.isNil(value)) {\n                        logEvent.changes.push([\"removed\", fieldName, value]);\n                    } else {\n                        logEvent.changes.push([\"changed\", fieldName, value]);\n                    }\n                }\n            } else {\n                // field was added\n                outerData[fieldName] = value;\n                newFields.add(fieldName);\n                newAndChangedFields.add(fieldName);\n                this.states[fieldName] = createInputState(fieldName);\n                this.states[fieldName].putValue(value);\n                logEvent.changes.push([\"added\", fieldName, value]);\n            }\n        });\n\n        logStoreEvent(logEvent);\n        this.actionCompleted.next(newAndChangedFields as any);\n\n        if (options.afterAction) {\n            options.afterAction(this, innerData, changedFields, newFields);\n        }\n    }\n\n    get data(): T {\n        let data = undefined;\n        // let data = Zone.current.get(ZoneKeyData);\n        return data === undefined ? this.currentData : data;\n    }\n\n    select<K extends keyof T>(...fields: K[]): Observable<SelectEvent<T>> {\n        let futureChanges = this.actionCompleted\n                .filter(touchedFields => {\n                    return _.some(fields, f => touchedFields.has(f));\n                });\n\n        let alreadyHasAllSelectedFields = _.every(fields, field => {\n            let state = this.states[field];\n            if (state === undefined) {\n                return false;\n            } else if (!state.hasValue()) {\n                return false;\n            }\n\n            return true;\n        });\n\n        if (alreadyHasAllSelectedFields) {\n            futureChanges = futureChanges.startWith(new Set(fields));\n        }\n\n        return futureChanges\n                .map(fields => {\n                    return {\n                        data: this.data,\n                        fields: new Set(fields)\n                    };\n                });\n    }\n\n    selectAll<K extends keyof T>(): Observable<SelectEvent<T>> {\n        const data: T = this.data;\n        const keys: string[] = _.keysIn(data);\n        const keysWithValues: string[] = keys.filter(key => _.get(data, key) !== undefined);\n        return this.actionCompleted\n                .startWith(new Set(keysWithValues))\n                .map(fields => {\n                    return {\n                        data: this.data,\n                        fields: fields\n                    };\n                });\n    }\n\n}\n"],"sourceRoot":"/"}