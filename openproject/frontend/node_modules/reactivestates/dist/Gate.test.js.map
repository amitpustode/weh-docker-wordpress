{"version":3,"sources":["../src/Gate.test.ts"],"names":["InputState_1","require","Gate_1","Combiner_1","describe","it","i1","input","gateFor","values$","subscribe","Error","done","gate","i","assert","equal","passOne","values","push","putValue","deepEqual","counter","nonValues$","changes$","val","clear","undefined","i2","i3","inputs","combine","isNonValue"],"mappings":"oEAAA,IAAAA,aAAAC,QAAA,gBACAC,OAAAD,QAAA,UACAE,WAAAF,QAAA,cAEAG,SAAS,OAAQ,WAEbC,GAAG,qCAAsC,WACrC,IAAMC,EAAKN,aAAAO,MAAM,GACJL,OAAAM,QAAQF,GAEhBG,UAAUC,UAAU,WACrB,MAAM,IAAIC,UAIlBN,GAAG,6BAA8B,SAAUO,GACvC,IAAMN,EAAKN,aAAAO,MAAM,GACXM,EAAOX,OAAAM,QAAQF,GAErBO,EAAKJ,UAAUC,UAAU,SAAAI,GACrBC,OAAOC,MAAMF,EAAG,GAChBF,MAGJC,EAAKI,YAGTZ,GAAG,sCAAuC,WACtC,IAAMC,EAAKN,aAAAO,MAAM,GACXM,EAAOX,OAAAM,QAAQF,GAEfY,KACNL,EAAKJ,UAAUC,UAAU,SAAAI,GACrBI,EAAOC,KAAKL,KAGhBD,EAAKI,UACLX,EAAGc,SAAS,GACZP,EAAKI,UAELF,OAAOM,UAAUH,GAAS,EAAG,MAGjCb,GAAG,sDAAuD,SAAUO,GAChE,IAAMN,EAAKN,aAAAO,MAAM,GACXM,EAAOX,OAAAM,QAAQF,GAErBO,EAAKJ,UAAUC,UAAU,SAAAI,GACrBC,OAAOC,MAAMF,EAAG,KAGpBD,EAAKI,UACLX,EAAGc,SAAS,GAEZR,MAGJP,GAAG,mCAAoC,SAAUO,GAC7C,IAAMN,EAAKN,aAAAO,QACLM,EAAOX,OAAAM,QAAQF,GAEjBgB,EAAU,EACdT,EAAKU,aAAab,UAAU,WAMR,MADhBY,GAEIV,MAIRC,EAAKI,YAGTZ,GAAG,wCAAyC,WACxC,IAAMC,EAAKN,aAAAO,QACLM,EAAOX,OAAAM,QAAQF,GAEjBY,KACJL,EAAKW,WAAWd,UACR,SAAAe,GACIP,EAAOC,KAAKM,KAGxBZ,EAAKI,UACLJ,EAAKI,UACLX,EAAGc,SAAS,GACZP,EAAKI,UACLJ,EAAKI,UACLX,EAAGc,SAAS,GACZP,EAAKI,UACLJ,EAAKI,UACLX,EAAGoB,QACHb,EAAKI,UACLJ,EAAKI,UAELF,OAAOM,UAAUH,QAASS,OAAWA,OAAWA,EAAW,EAAG,EAAG,EAAG,OAAGA,OAAWA,MAGtFtB,GAAG,8DAA+D,WAC9D,IAAMC,EAAKN,aAAAO,QACLqB,EAAK5B,aAAAO,QACLsB,EAAK7B,aAAAO,QACLuB,EAAS3B,WAAA4B,QAAQzB,EAAIsB,EAAIC,GACzBhB,EAAOX,OAAAM,QAAQsB,GAEjBZ,KACJL,EAAKW,WAAWd,UACR,SAACe,GACGP,EAAOC,MAAMW,EAAOE,WAAWP,GAAMA,MAGjDZ,EAAKI,UACLX,EAAGc,SAAS,GACZP,EAAKI,UACLW,EAAGR,SAAS,GACZP,EAAKI,UACLY,EAAGT,SAAS,GACZP,EAAKI,UACLW,EAAGF,QACHb,EAAKI,UAELF,OAAOM,UACCH,KAEK,OAAMS,KACN,QAAOA,OAAWA,OAAWA,MAC7B,GAAO,OAAGA,OAAWA,MACrB,GAAO,EAAG,OAAGA,MACb,GAAQ,EAAG,EAAG,MACd,GAAO,OAAGA,EAAW","file":"Gate.test.js","sourcesContent":["import {input} from \"./InputState\";\nimport {gateFor} from \"./Gate\";\nimport {combine} from \"./Combiner\";\n\ndescribe(\"Gate\", function () {\n\n    it(\"does not pass input after creation\", function () {\n        const i1 = input(1);\n        const gate = gateFor(i1);\n\n        gate.values$().subscribe(() => {\n            throw new Error();\n        });\n    });\n\n    it(\"pass input after passOne()\", function (done) {\n        const i1 = input(1);\n        const gate = gateFor(i1);\n\n        gate.values$().subscribe(i => {\n            assert.equal(i, 1);\n            done();\n        });\n\n        gate.passOne();\n    });\n\n    it(\"pass inputs on every passOne() call\", function () {\n        const i1 = input(1);\n        const gate = gateFor(i1);\n\n        const values: number[] = [];\n        gate.values$().subscribe(i => {\n            values.push(i);\n        });\n\n        gate.passOne();\n        i1.putValue(2);\n        gate.passOne();\n\n        assert.deepEqual(values, [1, 2]);\n    });\n\n    it(\"pass input after passOne() but not following values\", function (done) {\n        const i1 = input(1);\n        const gate = gateFor(i1);\n\n        gate.values$().subscribe(i => {\n            assert.equal(i, 1);\n        });\n\n        gate.passOne();\n        i1.putValue(2);\n\n        done();\n    });\n\n    it(\"pass nonValue input with passOne\", function (done) {\n        const i1 = input<number>();\n        const gate = gateFor(i1);\n\n        let counter = 0;\n        gate.nonValues$().subscribe(() => {\n            // nonValuesSink will be called two times:\n            // 1. nonValue state of gate\n            // 2. nonvalue state from input after gate.passOne();\n\n            counter++;\n            if (counter === 2) {\n                done();\n            }\n        });\n\n        gate.passOne();\n    });\n\n    it(\"correctly passes nonValues and values\", function () {\n        const i1 = input<number>();\n        const gate = gateFor(i1);\n\n        let values: (number|undefined)[] = [];\n        gate.changes$().subscribe(\n                val => {\n                    values.push(val);\n                });\n\n        gate.passOne();\n        gate.passOne();\n        i1.putValue(1);\n        gate.passOne();\n        gate.passOne();\n        i1.putValue(2);\n        gate.passOne();\n        gate.passOne();\n        i1.clear();\n        gate.passOne();\n        gate.passOne();\n\n        assert.deepEqual(values, [undefined, undefined, undefined, 1, 1, 2, 2, undefined, undefined]);\n    });\n\n    it(\"correctly passes nonValues and values from a combined input\", function () {\n        const i1 = input<number>();\n        const i2 = input<number>();\n        const i3 = input<number>();\n        const inputs = combine(i1, i2, i3);\n        const gate = gateFor(inputs);\n\n        let values: [boolean, any][] = [];\n        gate.changes$().subscribe(\n                (val: any) => {\n                    values.push([inputs.isNonValue(val), val]);\n                });\n\n        gate.passOne();\n        i1.putValue(1);\n        gate.passOne();\n        i2.putValue(2);\n        gate.passOne();\n        i3.putValue(3);\n        gate.passOne();\n        i2.clear();\n        gate.passOne();\n\n        assert.deepEqual<any>(\n                values,\n                [\n                    [true, undefined],\n                    [true, [undefined, undefined, undefined]],\n                    [true, [1, undefined, undefined]],\n                    [true, [1, 2, undefined]],\n                    [false, [1, 2, 3]],\n                    [true, [1, undefined, 3]],\n                ]\n        );\n    });\n\n});\n"],"sourceRoot":"/"}