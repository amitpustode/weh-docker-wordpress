{"version":3,"sources":["../src/State.ts"],"names":["observableToState","input$","State","x","undefined","state","setStateFn","pristine","hasValue","rxjs_1","require","log_1","source$","isNonValue","afterConnect","afterDisconnect","_this","this","name","logEnabled","outputStreamTrailing","ReplaySubject","observerCount","timestampOfLastValue","outputStream","value$","filter","v","nonValue$","inputStream","connect","prototype","isConnected","disconnect","sourceSubscription","subscribe","val","setInnerValue","bind","unsubscribe","isValueOlderThan","timeoutInMs","Date","now","stateValue","changes$","reason","wrapObserve","asObservable","changesPromise","take","toPromise","values$","valuesPromise","nonValues$","nonValuesPromise","Object","defineProperty","getValueOr","or","value","mapOr","fn","orValue","forEach","toString","getSubscriberCount","hasSubscribers","onObserverSubscribed","onObserverUnsubscribed","log","logStateChange","next","$","Observable","create","subscriber","sub","error","complete","exports"],"mappings":"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","file":"State.js","sourcesContent":["import {Observable, ReplaySubject, Subscription} from \"rxjs\";\nimport {Observer} from \"rxjs/Observer\";\nimport {Subject} from \"rxjs/Subject\";\nimport {logStateChange} from \"./log\";\n\nexport type IsNonValueFn<T, X> = (x: T | X) => x is X;\nexport type AfterConnectFn<T, X> = (state: State<T, X>, setStateFn: (val: T | X) => void) => void;\nexport type AfterDisConnectFn<T, X> = (state: State<T, X>, setStateFn: (val: T | X) => void) => void;\n\nexport class State<T, X = undefined> {\n\n    public name: string|null = null;\n\n    public logEnabled = true;\n\n    public pristine = true;\n\n    public outputStreamTrailing: Subject<T | X> = new ReplaySubject<T | X>(1);\n\n    protected stateValue: T | X;\n\n    private inputStream: Observable<T | X>;\n\n    private sourceSubscription: Subscription | undefined;\n\n    private observerCount = 0;\n\n    private timestampOfLastValue = -1;\n\n    private outputStream: Subject<T | X> = new ReplaySubject<T | X>(1);\n\n    private value$: Observable<T> = this.outputStream.filter(v => !this.isNonValue(v));\n\n    private nonValue$: Observable<X> = this.outputStream.filter(v => this.isNonValue(v));\n\n    constructor(source$: Observable<T | X>,\n                public readonly isNonValue: (val: T | X) => val is X,\n                private readonly afterConnect: AfterConnectFn<T, X>,\n                private readonly afterDisconnect: AfterDisConnectFn<T, X>\n                /*private readonly getNonValue: () => X*/) {\n\n        this.inputStream = source$;\n        this.connect();\n    }\n\n    public connect(): this {\n        if (this.isConnected()) {\n            this.disconnect();\n        }\n        this.sourceSubscription = this.inputStream\n                .subscribe(val => {\n                    this.setInnerValue(val);\n                });\n\n        this.afterConnect(this, this.setInnerValue.bind(this));\n        return this;\n    }\n\n    public disconnect(): this {\n        // if (this.hasValue()) {\n        //     this.setInnerValue(this.getNonValue());\n        // }\n        this.afterDisconnect(this, this.setInnerValue.bind(this));\n\n        this.sourceSubscription && this.sourceSubscription.unsubscribe();\n        this.sourceSubscription = undefined;\n        this.pristine = true;\n        return this;\n    }\n\n    public isConnected(): boolean {\n        return this.sourceSubscription !== undefined;\n    }\n\n    public isValueOlderThan(timeoutInMs: number): boolean {\n        const ageValue = Date.now() - this.timestampOfLastValue;\n        return ageValue > timeoutInMs;\n    }\n\n    /**\n     * Returns true if this state has a value.\n     */\n    public hasValue(): boolean {\n        return !this.isNonValue(this.stateValue);\n    }\n\n    public changes$(reason?: string): Observable<T | X> {\n        return this.wrapObserve(this.outputStream.asObservable(), reason);\n    }\n\n    public changesPromise(): PromiseLike<T | X> {\n        return this.changes$().take(1).toPromise();\n    }\n\n    public values$(reason?: string): Observable<T> {\n        return this.wrapObserve(this.value$, reason);\n    }\n\n    public valuesPromise(): PromiseLike<T | undefined> {\n        return this.values$().take(1).toPromise();\n    }\n\n    public nonValues$(reason?: string): Observable<X> {\n        return this.wrapObserve(this.nonValue$, reason);\n    }\n\n    public nonValuesPromise(): PromiseLike<T | X> {\n        return this.nonValues$().take(1).toPromise();\n    }\n\n    public get value(): T | X {\n        return this.stateValue;\n    }\n\n    public getValueOr<B>(or: B): T | B {\n        return this.hasValue() ? this.value as T : or;\n    }\n\n    public mapOr<R>(fn: (v: T) => R, orValue: R): R {\n        if (this.hasValue()) {\n            return fn(this.value as T);\n        } else {\n            return orValue;\n        }\n    }\n\n    public forEach(fn: (v: T) => void): this {\n        this.values$().subscribe(v => fn(v));\n        return this;\n    }\n\n    public get text(): string {\n        return this.hasValue() ? this.value!.toString() : \"\";\n    }\n\n    public getSubscriberCount(): number {\n        return this.observerCount;\n    }\n\n    public hasSubscribers(): boolean {\n        return this.getSubscriberCount() > 0;\n    }\n\n    protected onObserverSubscribed(): void {\n    }\n\n    protected onObserverUnsubscribed(): void {\n    }\n\n    protected log() {\n        logStateChange(this);\n    }\n\n    protected setInnerValue(val: T | X): void {\n        this.stateValue = val;\n        this.pristine = false;\n\n        if (this.logEnabled) {\n            this.log();\n        }\n\n        if (!this.isNonValue(val)) {\n            this.timestampOfLastValue = Date.now();\n        } else {\n            this.timestampOfLastValue = -1;\n        }\n\n        this.outputStream.next(val);\n        this.outputStreamTrailing.next(val);\n    }\n\n    private wrapObserve<O extends T | X>($: Observable<O>, reason?: string): Observable<O> {\n        return Observable.create((subscriber: Observer<O>) => {\n            this.observerCount++;\n            this.onObserverSubscribed();\n            const sub = $.subscribe(\n                    val => {\n                        if (reason !== undefined) {\n                            // TODO\n                            // this.log(\"-> \" + reason);\n                        }\n                        subscriber.next(val);\n                    }, error => {\n                        subscriber.error(error);\n                    }, () => {\n                        subscriber.complete();\n                    }\n            );\n\n            return () => {\n                sub.unsubscribe();\n                this.observerCount--;\n                this.onObserverUnsubscribed();\n            };\n        });\n    }\n\n}\n\nexport function observableToState<T>(input$: Observable<T | undefined>): State<T, undefined> {\n    return new State<T, undefined>(\n            input$,\n            (x): x is undefined => x === undefined,\n            (state, setStateFn) => {\n                if (state.pristine) {\n                    setStateFn(undefined);\n                }\n            }, (state, setStateFn) => {\n                if (state.hasValue()) {\n                    setStateFn(undefined);\n                }\n            });\n}\n\n"],"sourceRoot":"/"}