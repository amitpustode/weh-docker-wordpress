{"version":3,"sources":["../src/DerivedState.test.ts"],"names":["DerivedState_1","require","InputState_1","describe","it","calls","input$","input","logEnabled","derived","deriveRaw","$","map","v","isNonValue","changes$","subscribe","val","push","JSON","stringify","putValue","undefined","assert","deepEqual","state2","derive","values$","equal","value","clear","isFalse","hasValue","filter","isTrue"],"mappings":"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","file":"DerivedState.test.js","sourcesContent":["import {derive, deriveRaw} from \"./DerivedState\";\nimport {input} from \"./InputState\";\n\ndescribe(\"DerivedState\", function () {\n\n    it(\"can transform the changes$ stream with deriveRaw()\", function () {\n        const calls: string[] = [];\n\n        const input$ = input<number>();\n        input$.logEnabled = true;\n\n        const derived = deriveRaw(\n                input$,\n                ($, input) => $\n                        .map(v => {\n                            if (input.isNonValue(v)) {\n                                return -1;\n                            } else {\n                                return v + 1000;\n                            }\n                        }));\n\n        input$.changes$().subscribe(val => {\n            calls.push(\"input:\" + JSON.stringify(val));\n        });\n\n        derived.changes$().subscribe(val => {\n            calls.push(\"derived:\" + JSON.stringify(val));\n        });\n\n        input$.putValue(1);\n        input$.putValue(undefined);\n        input$.putValue(2);\n\n        assert.deepEqual(calls, [\n            \"input:undefined\",\n            \"derived:-1\",\n\n            \"input:1\",\n            \"derived:1001\",\n\n            \"input:undefined\",\n            \"derived:-1\",\n\n            \"input:2\",\n            \"derived:1002\"\n        ]);\n    });\n\n    it(\"can transform the values$ stream with derive()\", function () {\n        const calls: string[] = [];\n\n        const input$ = input<number>();\n\n        const state2 = derive<number, number>(input$, $ => $.map(v => v + 1000));\n\n        input$.changes$().subscribe(val => {\n            calls.push(\"state1:\" + JSON.stringify(val));\n        });\n\n        state2.changes$().subscribe(val => {\n            calls.push(\"state2:\" + JSON.stringify(val));\n        });\n\n        input$.putValue(1);\n        input$.putValue(undefined);\n        input$.putValue(2);\n\n        assert.deepEqual(calls, [\n            \"state1:undefined\",\n            \"state2:undefined\",\n            \"state1:1\",\n            \"state2:1001\",\n            \"state1:undefined\",\n            \"state2:undefined\",\n            \"state1:2\",\n            \"state2:1002\",\n        ]);\n    });\n\n    it(\"inherits the cleared-state from its input\", function () {\n        const input$ = input<number>(1);\n        const derived = derive(input$, $ => $.map(v => v + 1000));\n        derived.values$().subscribe();\n\n        assert.equal(input$.value, 1);\n        assert.equal(derived.value, 1001);\n        input$.clear();\n        assert.isFalse(input$.hasValue());\n        assert.isFalse(derived.hasValue());\n    });\n\n    it(\"can filter/limit the input stream\", function () {\n        const input$ = input<number>(1);\n        const derived = derive(input$, $ => $.filter(v => v === 2));\n        derived.values$().subscribe();\n\n        assert.equal(input$.value, 1);\n        assert.isFalse(derived.hasValue());\n        input$.putValue(2);\n        assert.equal(input$.value, 2);\n        assert.isTrue(derived.hasValue());\n    });\n\n    it(\"can switch to a cleared state independent from its input\", function () {\n        const input$ = input<number>(1);\n        const derived = derive(input$, $ => $.map(v => v === 2 ? undefined : v));\n        derived.values$().subscribe();\n\n        assert.equal(input$.value, 1);\n        assert.equal(derived.value, 1);\n        input$.putValue(2);\n        assert.equal(input$.value, 2);\n        assert.isFalse(derived.hasValue());\n    });\n\n    // it(\"does not execute the inner transformer without subscribers\", function () {\n    //     const input$ = input(1);\n    //     deriveRaw(input$, $ => $\n    //             .map(() => {\n    //                 throw Error();\n    //             }));\n    // });\n\n    // it(\"can be switched to be eager\", function (done) {\n    //     const input$ = input(1);\n    //     derive(input$, $ => $.do(() => done())).eager();\n    // });\n\n    // it(\"executes the inner transformer once an observer subscribes\", function (done) {\n    //     const input$ = input(1);\n    //     const derived$ = deriveRaw(input$, $ => $\n    //             .map(() => {\n    //                 return \"X\";\n    //             }));\n    //\n    //     derived$.changes$().subscribe(v => {\n    //         assert.equal(v, \"X\");\n    //         done();\n    //     });\n    // });\n\n    // it(\"does not execute the inner transformer once the last observer unsubscribes\", function () {\n    //     const calls: any[] = [];\n    //     const input$ = input(1);\n    //     const derived$ = deriveRaw(input$, $ => $\n    //             .map(v => calls.push(v)));\n    //\n    //     let sub1 = derived$.changes$().subscribe();\n    //\n    //     input$.putValue(2);\n    //\n    //     let sub2 = derived$.changes$().subscribe();\n    //\n    //     input$.putValue(3);\n    //     sub2.unsubscribe();\n    //     input$.putValue(4);\n    //     sub1.unsubscribe();\n    //     input$.putValue(5);\n    //\n    //     assert.deepEqual(calls, [1, 2, 3, 4]);\n    // });\n\n    // it(\"value() only has a value if an observer is subscribed\", function () {\n    //     const input$ = input(1);\n    //     const derived$ = deriveRaw(input$, $ => $\n    //             .map(() => {\n    //                 return \"X\";\n    //             }));\n    //\n    //     assert.isUndefined(derived$.value);\n    //\n    //     derived$.changes$().subscribe();\n    //     assert.equal(derived$.value, \"X\");\n    // });\n\n    // it(\"in a chain of DependentState, only an observer triggers the inner transformers\", function () {\n    //     const calls: any[] = [];\n    //     const input$ = input(1);\n    //     const derived1$ = deriveRaw(input$, $ => $.map(() => calls.push(1)));\n    //     const derived2$ = deriveRaw(derived1$, $ => $.map(() => calls.push(2)));\n    //     const derived3$ = deriveRaw(derived2$, $ => $.map(() => calls.push(3)));\n    //\n    //     assert.deepEqual(calls, []);\n    //\n    //     derived3$.changes$().subscribe();\n    //\n    //     assert.deepEqual(calls, [1, 2, 3]);\n    // });\n\n    it(\"can have an initial value\", function () {\n        const calls: any[] = [];\n        const input$ = input<number>();\n        const derived$ = derive(input$, $ => $, 1);\n        derived$.changes$().subscribe(v => calls.push(v));\n        input$.putValue(2);\n        assert.deepEqual(calls, [1, 2]);\n    });\n\n    it(\"initial value is only used at the beginning, not as a replacement for cleared\", function () {\n        const calls: any[] = [];\n        const input$ = input<number>();\n        const derived$ = derive(input$, $ => $, 1);\n        derived$.changes$().subscribe(v => calls.push(v));\n        input$.putValue(2);\n        input$.clear();\n        assert.deepEqual(calls, [1, 2, undefined]);\n    });\n\n});\n"],"sourceRoot":"/"}