{"version":3,"sources":["../src/State.test.ts"],"names":["rxjs_1","require","State_1","describe","it","dummy","Subject","s1","observableToState","assert","isFalse","hasValue","done","values$","subscribe","val","equal","next","changes$","i","undefined","nonValues$","isTrue","mapOr","v","a","calls","forEach","push","deepEqual","skip","disconnect","connect","setTimeout","isValueOlderThan","valuesPromise","then","getSubscriberCount","sub1","sub2","unsubscribe","value"],"mappings":"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","file":"State.test.js","sourcesContent":["import {Subject} from \"rxjs\";\nimport {observableToState, State} from \"./State\";\n\ndescribe(\"State\", function () {\n\n    it(\"has NonValue after creation\", function () {\n        const dummy = new Subject<number>();\n        const s1: State<number, undefined> = observableToState(dummy);\n        assert.isFalse(s1.hasValue());\n    });\n\n    it(\"future values can be subscribed with values$\", function (done) {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n        s1.values$().subscribe(val => {\n            assert.equal(val, 1);\n            done();\n        });\n        dummy.next(1);\n    });\n\n    it(\"changes$ has 'undefined' state after creation\", function (done) {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n        s1.changes$()\n                .subscribe(i => {\n                    assert.equal(i, undefined);\n                    done();\n                });\n    });\n\n    it(\"nonValues$ has 'undefined' state after creation\", function (done) {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n        s1.nonValues$()\n                .subscribe(i => {\n                    assert.equal(i, undefined);\n                    done();\n                });\n    });\n\n    it(\"replays the last value\", function (done) {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n        dummy.next(1);\n        s1.values$()\n                .subscribe(i => {\n                    assert.isTrue(s1.hasValue());\n                    assert.equal(i, 1);\n                    done();\n                });\n    });\n\n    it(\"mapOr\", () => {\n        const dummy = new Subject<{ a: number }>();\n        const s1 = observableToState(dummy);\n\n        assert.equal(s1.mapOr(v => v.a, 1), 1);\n        dummy.next({a: 2});\n        assert.equal(s1.mapOr(v => v.a, 1), 2);\n    });\n\n    it(\"forEach\", () => {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n\n        const calls: number[] = [];\n        dummy.next(1);\n        dummy.next(2);\n        s1.forEach(v => calls.push(v));\n        dummy.next(3);\n        dummy.next(4);\n        dummy.next(5);\n\n        assert.deepEqual(calls, [2, 3, 4, 5]);\n    });\n\n    it(\"the value 'undefined' clears the state\", function () {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n        dummy.next(1);\n        dummy.next(undefined);\n        assert.isFalse(s1.hasValue());\n    });\n\n    it(\"clearing can be observed\", function (done) {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n\n        s1.nonValues$()\n                .skip(1)\n                .subscribe(i => {\n                    assert.equal(i, undefined);\n                    assert.isFalse(s1.hasValue());\n                    done();\n                });\n\n        dummy.next(1);\n        dummy.next(undefined);\n    });\n\n    it(\"can be disconnected/connected\", function (done) {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n        s1.disconnect();\n        dummy.next(1);\n        assert.isFalse(s1.hasValue());\n        s1.connect();\n        dummy.next(2);\n        assert.isTrue(s1.hasValue());\n        s1.values$()\n                .subscribe(i => {\n                    assert.isTrue(s1.hasValue());\n                    assert.equal(i, 2);\n                    done();\n                });\n    });\n\n    it(\"remembers the timestamp of the last value\", function (done) {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n        dummy.next(1);\n        setTimeout(() => {\n            assert.isTrue(s1.isValueOlderThan(1));\n            done();\n        }, 5);\n    });\n\n    it(\"fires correctly when using valuesPromise\", function (done) {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n        dummy.next(1);\n\n        s1.valuesPromise().then(() => done());\n    });\n\n    it(\"counts the number of observers\", function () {\n        const dummy = new Subject<number>();\n        const s1 = observableToState(dummy);\n        assert.equal(s1.getSubscriberCount(), 0);\n        const sub1 = s1.values$().subscribe(v => v);\n        assert.equal(s1.getSubscriberCount(), 1);\n        const sub2 = s1.values$().subscribe(v => v);\n        assert.equal(s1.getSubscriberCount(), 2);\n        sub1.unsubscribe();\n        assert.equal(s1.getSubscriberCount(), 1);\n        sub2.unsubscribe();\n        assert.equal(s1.getSubscriberCount(), 0);\n    });\n\n    it(\"value / nonValue states over time\", function () {\n        const value = new Subject<number>();\n        const s1 = observableToState(value);\n\n        let calls: string[] = [];\n        s1.nonValues$().subscribe(v => calls.push(\"nonValue\"));\n        s1.values$().subscribe(v => calls.push(\"value:\" + v));\n\n        value.next(1);\n        value.next(2);\n        value.next(undefined);\n        value.next(3);\n\n        assert.deepEqual(calls, [\"nonValue\", \"value:1\", \"value:2\", \"nonValue\", \"value:3\"]);\n    });\n\n});\n"],"sourceRoot":"/"}