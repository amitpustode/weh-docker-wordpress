{"version":3,"sources":["../src/DerivedState.ts"],"names":["deriveRaw","state","transformer","transformed","outputStreamTrailing","DerivedState","val","undefined","derive","defaultWhenInputHasNonValue","values$","filter","v","isNonValue","nonValues$","map","nonValue","source$","rxjs_1","Observable","merge","require","State_1","_super","inputState","stream","defaultNonValue","_this","this","afterConnect","setStateFn","hasValue","afterDisConnect","call","__extends","State","exports"],"mappings":"aAyDA,SAAAA,UAAsCC,EACAC,GAElC,IAAMC,EAA0CD,EAAYD,EAAMG,qBAAsBH,GAKxF,OAAO,IAAII,aAAoCJ,EAAOE,EAJnC,SAACG,GAChB,YAAeC,IAARD,QAGoEC,OAAWA,GAG9F,SAAAC,OAA+CP,EACAC,EACAO,GAE3C,IAAMC,EAA0BR,EACxBD,EAAMG,qBAAqBO,OAAO,SAAAC,GAAK,OAACX,EAAMY,WAAWD,KAAKX,GAEhEa,EACEb,EAAMG,qBAAqBO,OAAO,SAAAC,GAAK,OAAAX,EAAMY,WAAWD,KAAIG,IAAI,SAAAC,MAElEC,EAAsCC,OAAAC,WAAWC,MAAMN,EAAYJ,GAKzE,OAAO,IAAIL,aAAoCJ,EAAOgB,EAJnC,SAACX,GAChB,YAAeC,IAARD,QAGgEC,EAAWE,yYAnF1F,IAAAS,OAAAG,QAAA,QACAC,QAAAD,QAAA,WAEAhB,aAAA,SAAAkB,GAMI,SAAAlB,EAAYmB,EACAC,EACAZ,EACAa,EACAjB,GAJZ,IAAAkB,EAAAC,KAMUC,EAAuC,SAAC5B,EAAO6B,GAC5C7B,EAAM8B,YACPD,EAAWrB,IAGbuB,EAA6C,SAAC/B,EAAO6B,GACvDA,EAAWJ,WAGfC,EAAAJ,EAAAU,KAAAL,KAAMH,EAAQZ,EAAYgB,EAAcG,IAAgBJ,KACxDD,EAAKH,WAAaA,EAClBG,EAAKlB,4BAA8BA,IA4B3C,OAnDkDyB,UAAA7B,EAAAkB,GAmDlDlB,GAnDkDiB,QAAAa,OAArCC,QAAA/B,aAAAA,aAsDb+B,QAAApC,UAAAA,UAWAoC,QAAA5B,OAAAA","file":"DerivedState.js","sourcesContent":["import {Observable} from \"rxjs\";\nimport {AfterConnectFn, AfterDisConnectFn, IsNonValueFn, State} from \"./State\";\n\nexport class DerivedState<IT, IX, OT, OX> extends State<OT, OX> {\n\n    private readonly inputState: State<IT, IX>;\n\n    private readonly defaultWhenInputHasNonValue?: OT | OX;\n\n    constructor(inputState: State<IT, IX>,\n                stream: Observable<OT | OX>,\n                isNonValue: IsNonValueFn<OT, OX>,\n                defaultNonValue: OX,\n                defaultWhenInputHasNonValue: OT | OX) {\n\n        const afterConnect: AfterConnectFn<OT, OX> = (state, setStateFn) => {\n            if (!state.hasValue()) {\n                setStateFn(defaultWhenInputHasNonValue);\n            }\n        };\n        const afterDisConnect: AfterDisConnectFn<OT, OX> = (state, setStateFn) => {\n            setStateFn(defaultNonValue);\n        };\n\n        super(stream, isNonValue, afterConnect, afterDisConnect);\n        this.inputState = inputState;\n        this.defaultWhenInputHasNonValue = defaultWhenInputHasNonValue;\n    }\n\n    // public connect(): this {\n    //     if (this.getObserverCount() === 0) {\n    //         return this;\n    //     }\n    //\n    //     super.connect();\n    //     return this;\n    // }\n\n    // public lazy(): this {\n    //     this.changes$(\"eager mode\").subscribe();\n    //     return this;\n    // }\n\n    // protected onObserverSubscribed() {\n    //     if (this.getObserverCount() === 1) {\n    //         this.connect();\n    //     }\n    // }\n    //\n    // protected onObserverUnsubscribed() {\n    //     if (this.getObserverCount() === 0) {\n    //         this.disconnect();\n    //     }\n    // }\n}\n\n\nexport function deriveRaw<IT, IX, OT>(state: State<IT, IX>,\n                                      transformer: ($: Observable<IT | IX>, inputState: State<IT, IX>) => Observable<OT | undefined>): DerivedState<IT, IX, OT, undefined> {\n\n    const transformed: Observable<OT | undefined> = transformer(state.outputStreamTrailing, state);\n    const isNonValue = (val: OT | undefined): val is undefined => {\n        return val === undefined;\n    };\n\n    return new DerivedState<IT, IX, OT, undefined>(state, transformed, isNonValue, undefined, undefined);\n}\n\nexport function derive<IT, OT, IX = undefined>(state: State<IT, IX>,\n                                               transformer: ($: Observable<IT>, inputState: State<IT, IX>) => Observable<OT|undefined>,\n                                               defaultWhenInputHasNonValue?: OT): DerivedState<IT, IX, OT, undefined> {\n\n    const values$: Observable<OT> = transformer(\n            state.outputStreamTrailing.filter(v => !state.isNonValue(v)), state);\n\n    const nonValues$: Observable<undefined> =\n            state.outputStreamTrailing.filter(v => state.isNonValue(v)).map(nonValue => undefined);\n\n    const source$: Observable<OT | undefined> = Observable.merge(nonValues$, values$);\n    const isNonValue = (val: OT | undefined): val is undefined => {\n        return val === undefined;\n    };\n\n    return new DerivedState<IT, IX, OT, undefined>(state, source$, isNonValue, undefined, defaultWhenInputHasNonValue);\n}\n"],"sourceRoot":"/"}