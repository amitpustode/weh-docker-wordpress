{"version":3,"sources":["../src/MultiInputState.ts"],"names":["multiInput","MultiInputState","rxjs_1","require","ReplaySubject_1","InputState_1","State_1","_super","_this","this","cache$","ReplaySubject","afterConnect","state","setStateFn","afterDisConnect","clear","call","asObservable","val","undefined","change$","Subject","remove$","__extends","prototype","id","value","disconnect","next","get","newState_1","input","name","changes$","takeUntil","observeRemove","filter","subscribe","remove","observeChange","State","exports"],"mappings":"aA4FA,SAAAA,aACI,OAAO,IAAIC,sZA7Ff,IAAAC,OAAAC,QAAA,QACAC,gBAAAD,QAAA,sBACAE,aAAAF,QAAA,gBACAG,QAAAH,QAAA,WAKAF,gBAAA,SAAAM,GAUI,SAAAN,IAAA,IAAAO,EAAAC,KAEUC,EAA4B,IAAIN,gBAAAO,cAAwB,GAExDC,EAAoD,SAACC,EAAOC,GAC9DA,OAEEC,EAA0D,SAACF,EAAOC,GACpEN,EAAKQ,QACLF,cAGJN,EAAAD,EAAAU,KAAAR,KACQC,EAAOQ,eACP,SAACC,GAA+B,YAAQC,IAARD,GAChCP,EACAG,IAAgBN,KAExBD,EAAKE,OAASA,EACdF,EAAKa,QAAU,IAAInB,OAAAoB,QACnBd,EAAKe,QAAU,IAAIrB,OAAAoB,UAoD3B,OAlFwCE,UAAAvB,EAAAM,GAiCpCN,EAAAwB,UAAAT,MAAA,WACI,IAAK,IAAIU,KAAMjB,KAAKkB,MACFlB,KAAKkB,MAAOD,GACpBE,aAKV,OAFAnB,KAAKC,OAAOmB,SAELpB,MAGXR,EAAAwB,UAAAK,IAAA,SAAIJ,GAAJ,IAAAlB,EAAAC,KACI,QAAwBW,IAApBX,KAAKkB,MAAOD,GAAmB,CAC/B,IAAMK,EAAW1B,aAAA2B,QACbvB,KAAKwB,OACLF,EAASE,KAAOxB,KAAKwB,KAAO,IAAMP,EAAK,KAE3CjB,KAAKkB,MAAOD,GAAMK,EAClBA,EAASG,WACAC,UAAU1B,KAAK2B,gBAAgBC,OAAO,SAAAlB,GAAO,OAAAA,IAAQO,KACrDY,UAAU,SAAAnB,GACPX,EAAKa,QAAQQ,MAAMH,EAAIP,EAAKY,MAExCtB,KAAKC,OAAOmB,KAAKpB,KAAKkB,OAG1B,OAAOlB,KAAKkB,MAAOD,IAGvBzB,EAAAwB,UAAAc,OAAA,SAAOb,GACH,IAAMb,EAAQJ,KAAKkB,MAAOD,GAQ1B,YAPcN,IAAVP,IACAA,EAAMe,oBACCnB,KAAKkB,MAAOD,GACnBjB,KAAKC,OAAOmB,KAAKpB,KAAKkB,OACtBlB,KAAKc,QAAQM,KAAKH,IAGfb,GAGXZ,EAAAwB,UAAAe,cAAA,WACI,OAAO/B,KAAKY,QAAQH,gBAGxBjB,EAAAwB,UAAAW,cAAA,WACI,OAAO3B,KAAKc,QAAQL,gBAG5BjB,GAlFwCK,QAAAmC,OAA3BC,QAAAzC,gBAAAA,gBAoFbyC,QAAA1C,WAAAA","file":"MultiInputState.js","sourcesContent":["import {Observable, Subject} from \"rxjs\";\nimport {ReplaySubject} from \"rxjs/ReplaySubject\";\nimport {input, InputState} from \"./InputState\";\nimport {AfterConnectFn, AfterDisConnectFn, State} from \"./State\";\nimport {BehaviorSubject} from \"rxjs/BehaviorSubject\";\n\nexport type Cache<T> = { [key: string]: InputState<T> };\n\nexport class MultiInputState<T> extends State<Cache<T>, undefined> {\n\n    private readonly cache$: Subject<Cache<T>>;\n\n    private readonly change$: Subject<[string, T | undefined, InputState<T>]>;\n\n    private readonly remove$: Subject<string>;\n\n    // private cache: Cache<T>;\n\n    constructor() {\n        // const cache: Cache<T> = {};\n        const cache$: Subject<Cache<T>> = new ReplaySubject<Cache<T>>(1);\n\n        const afterConnect: AfterConnectFn<Cache<T>, undefined> = (state, setStateFn) => {\n            setStateFn({});\n        };\n        const afterDisConnect: AfterDisConnectFn<Cache<T>, undefined> = (state, setStateFn) => {\n            this.clear();\n            setStateFn({});\n        };\n\n        super(\n                cache$.asObservable(),\n                (val: any): val is undefined => val === undefined,\n                afterConnect,\n                afterDisConnect);\n\n        this.cache$ = cache$;\n        this.change$ = new Subject();\n        this.remove$ = new Subject();\n    }\n\n    clear(): this {\n        for (let id in this.value!) {\n            const state = this.value![id];\n            state.disconnect();\n        }\n\n        this.cache$.next({});\n\n        return this;\n    }\n\n    get(id: string): InputState<T> {\n        if (this.value![id] === undefined) {\n            const newState = input<T>();\n            if (this.name) {\n                newState.name = this.name + \"[\" + id + \"]\";\n            }\n            this.value![id] = newState;\n            newState.changes$()\n                    .takeUntil(this.observeRemove().filter(val => val === id))\n                    .subscribe(val => {\n                        this.change$.next([id, val, newState]);\n                    });\n            this.cache$.next(this.value!);\n        }\n\n        return this.value![id];\n    }\n\n    remove(id: string): InputState<T> | undefined {\n        const state = this.value![id];\n        if (state !== undefined) {\n            state.disconnect();\n            delete this.value![id];\n            this.cache$.next(this.value!);\n            this.remove$.next(id);\n        }\n\n        return state;\n    }\n\n    observeChange(): Observable<[string, T | undefined, InputState<T>]> {\n        return this.change$.asObservable();\n    }\n\n    observeRemove(): Observable<string> {\n        return this.remove$.asObservable();\n    }\n\n}\n\nexport function multiInput<T>(): MultiInputState<T> {\n    return new MultiInputState<T>();\n}\n"],"sourceRoot":"/"}